
@insert title

@section TP {Copying this document}
 Copyright (c) @insert author.  Permission is granted to copy,
 distribute and/or modify this document under the terms of the GNU Free
 Documentation License, Version 1.3 or any later version published by
 the Free Software Foundation; with no Invariant Sections, no
 Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is
 included in the section entitled @xref{GNU Free Documentation License}.

 This document was generated against svn revision @rcs $Rev: 53 $ of
 the documentation.
@end section

@ifopt doc_format {html}
 @section PH {Table of contents}
  @insert toc
 @end section
@end ifopt

@section TP {Features}

 @include description.mkdoc

 Features overview:

 @include features.mkdoc

@end section

@moduledef {Base}
 @short Lua base classes
@end group

@moduledef {Functions export}
 @short Expose C++ functions to lua
@end group

@moduledef {Model/View}
 @short Lua / Qt model view hierarchic data structure classes
@end group

@moduledef {Container proxies}
 @short Lua / Qt containers wrapper classes
@end group

@moduledef {QObject wrapping}
 @short QObject meta wrapper classes
 @internal
@end group

@section TP {QtLua lua libraries}

 QtLua comes with two lua libraries: a few general purpose global lua functions useful when running lua script
 from the QtLua environment, and a Qt library which give access to Qt essential functions.

 @section T {Predefined lua functions}
  The @ref QtLua::QtLuaLib library contains the following lua functions:
  @list
   @item The @tt print() lua function prints all passed values using the @ref QtLua::State::output signal.
   @item The @tt list() lua function prints list of members of given table or global table if no argument.
   @item The @tt each() lua function returns a lua iterator which can be used to iterate over lua tables and QtLua @ref UserData objects.
   @item The @tt help() lua function can be used to display help about @ref QtLua::Function based objects.
   @item The @tt plugin() function returns a @ref QtLua::Plugin object loaded from given plugin bare file name.
  @end list
 @end section

 @section T{Wrapped Qt functions}
  The @ref QtLua::QtLib library contains some wrapped Qt functions and objects:

  @list
   @item The @tt qt.connect() and @tt qt.disconnect() functions manage signals and slots connections, see @xref{Dynamic signals and slots}.
   @item The @tt qt.dialog table contains all functions needed to display Qt dialogs.
   @item The @tt qt.load_ui() function returns a Qt user interface file loaded using the @ref QUiLoader::load function.
   @item The @tt qt.menu table contains functions to manage Qt menus.
   @item The @tt qt.meta table contains all wrapped Qt meta objects, useful to access Qt enums and other meta data without @ref QObject instance.
   @item The @tt qt.new_widget() function returns a new widget of given class name using the @ref QUiLoader::createWidget function.
  @end list

 @end section
@end section

@section TP {Error handling and exceptions}

  Lua error handling is wrapped using C++ exceptions.

  Any lua code raising an error will throw a @ref QtLua::String
  exception in calling C++ code.

  Any @ref QtLua::String exception thrown will be reported as an error
  in calling lua code.

@end section

@section TP {Qt/Lua types conversion}

 This section is about data types conversion between lua and Qt.

 @section T {QtLua::Value types conversion}
  Lua values are exposed to Qt by @ref QtLua::Value objects in C++
  code. A @ref QtLua::Value object can be converted to or
  get constructed from an equivalent C++ value:

  @table 2
   @item Lua type	
   @item Qt/C++ type

   @item boolean
   @item @ref QtLua::Value::Bool

   @item number
   @item int, double

   @item string
   @item @ref QtLua::String, const char*

   @item table
   @item @ref QHash, @ref QMap, @ref QList, @ref QVector

   @item userdata
   @item Any @ref QtLua::UserData based class
  @end table
 @end section

 @section T {Qt meta types conversion}
  Types commonly used by the Qt meta object system are automatically
  converted to and from lua values when needed. It occurs on slot invocation
  for arguments and return values, on Qt enums and properties
  values reading and writing, on lua function invocation from Qt Signal...

  The following table shows how types get converted:

  @table 2
   @item Lua type			
   @item Qt meta type id

   @item boolean
   @item @ref QMetaType::Bool

   @item number	
   @item @ref QMetaType::Int

   @item number	
   @item @ref QMetaType::UInt

   @item number	
   @item @ref QMetaType::Long

   @item number	
   @item @ref QMetaType::LongLong

   @item number	
   @item @ref QMetaType::Short

   @item number	
   @item @ref QMetaType::Char

   @item number	
   @item @ref QMetaType::ULong

   @item number	
   @item @ref QMetaType::ULongLong

   @item number	
   @item @ref QMetaType::UShort

   @item number	
   @item @ref QMetaType::UChar

   @item number	
   @item @ref QMetaType::Double

   @item number	
   @item @ref QMetaType::Float

   @item number	
   @item @ref QMetaType::QChar

   @item string	
   @item @ref QMetaType::QString

   @item string	
   @item @ref QMetaType::QByteArray

   @item table of strings indexed from 1
   @item @ref QMetaType::QStringList

   @item userdata (see @xref {QObject wrapping})
   @item @ref QMetaType::QObjectStar

   @item userdata (see @xref {QObject wrapping}) 
   @item @ref QMetaType::QWidgetStar

   @item table with @tt width and @tt height fields
   @item @ref QMetaType::QSize

   @item table with @tt width and @tt height fields
   @item @ref QMetaType::QSizeF

   @item table with @tt x and @tt y fields
   @item @ref QMetaType::QPoint

   @item table with @tt x and @tt y fields
   @item @ref QMetaType::QPointF

   @item table with @tt x, @tt y, @tt width and @tt height fields
   @item @ref QMetaType::QRect

   @item table with @tt x, @tt y, @tt width and @tt height fields
   @item @ref QMetaType::QRectF

   @item userdata (see @ref QtLua::UserData) 
   @item meta type registered with @tt qRegisterMetaType<Ref<UserData>>

   @item nil
   @item Not handled Qt meta types
  @end table

 @end section

@end section

@section TP {QObject wrapping}

  Wrapping of @ref QObject objects allows use of Qt widgets and objects from lua.
 
  QtLua heavily takes advantage of the Qt meta object system to expose
  all QObjects signals, slots, enums, properties and child objects to lua script.

  See @xref{The qtlua interpreter tool} section for examples of @ref QObject manipulation from lua script.

  @section T{QObject ownership}

   Lua uses a garbage collector to track references to live values and
   QtLua provides the @ref QtLua::Ref smart pointer class to track references
   to @ref QtLua::UserData based objects, but Qt doesn't provide a way to track
   every pointer to @ref QObject objects.

   @ref QObject objects are seen from lua has an userdata value which
   provides access to child objects and to Qt meta fields like methods,
   properties... This userdata value is an internal @ref QtLua::UserData
   based wrapper with a pointer to the actual @ref QObject.

   We have no way to know if C++ pointers to the wrapped @ref QObject
   exist or if the wrapper will be the single owner. Unfortunately we
   still have to take the right action when the wrapper get garbage
   collected.

   The following rules apply:
   @list
    @item There is a single wrapper instance for a given @ref QObject.
    @item The wrapper is created when the @ref QObject is first exposed as a lua value through a @ref QtLua::Value object.
    @item A delete flag is carried by the wrapper.
    @item The wrapper will delete the associated @ref QObject when garbage collected only if its delete flag is set.
    @item The delete flag is set on wrapper creation only if the @ref QObject has a parent with the delete flag set.
    @item The delete flag can be updated from C++ code using the @ref QtLua::Value::__Value_qobject__ constructor.
    @item The wrapper can become void/empty if the associated @ref QObject get destroyed.
   @end list

  New @ref QObject wrappers returned by the @ref QtLua::QtLib {QtLib lua library} functions have their delete flag set.

  A reparent flag is also available to allow or deny parent change for a @ref QObject.

  The example below shows how @ref QObject ownership is handled in C++ code:
  @example examples/cpp/qobject/qobject_owner.cc:1

  @end section

  @section T{Dynamic signals and slots}
   Qt signals and slots connections can be managed dynamically from
   lua script. Moreover a Qt signal can be connected directly to a lua
   function.

   The @tt qt.connect lua function can be used to
   connect a Qt slot either to a Qt signal or to a lua function:

   @code
   -- connect signal and slot of given Qt objects
   qt.connect(qobjectwrapper1, "qt_signal_name", qobjectwrapper2, "qt_slot_name")

   -- connect slot to given lua function
   qt.connect(qobjectwrapper, "qt_signal_name", lua_function)
   @end code

   When a lua function is called from a Qt signal, its first argument
   is the sender object and following arguments are converted signal
   parameters (see @xref{Qt/Lua types conversion}).

   The @tt qt.disconnect lua functions can be used to
   disconnect a Qt slot:

   @code
   -- disconnect signal and slot of given Qt objects
   qt.disconnect(qobjectwrapper1, "qt_signal_name", qobjectwrapper2, "qt_slot_name")

   -- disconnect signal from given lua function
   qt.disconnect(qobjectwrapper, "qt_signal_name", lua_function)

   -- disconnect signal from all connected lua functions
   qt.disconnect(qobjectwrapper, "qt_signal_name")
   @end code
  @end section

@end section

@section TP {The qtlua interpreter tool}

 @section T{Description}

  The QtLua project comes with a simple tool to experiment Qt enabled lua scripts.
  
  Lua script files passed on command line are executed in left to
  right order. Standard lua libraries are loaded along with the
  @xref{QtLua lua libraries}. the lua global variable @tt app is
  wrapping the @ref QApplication object.

  This tool has an interactive mode which displays a @ref QtLua::Console window.
  This is useful for script debugging and allows playing with Qt objects from lua.

  The interactive mode is automatically started if no script are passed
  on command line, it can also be invoked with the @tt -i option on
  the command line and will start after scripts execution.

  When in interactive mode, the @tt{list()} and @tt{help()} commands
  are useful to get started.

 @end section

 @section T{Example 1 : Hello world}

  This simple example contains two files: a lua script file and an user
  interface file created with the Qt @tt designer tool:
  
  @code
  $ cd examples/lua/hello/
  $ ls
  hello.lua  hello.ui
  @end code
  
  Lua script file content:
  
  @example examples/lua/hello/hello.lua
  
  This window is displayed when the script is executed with the @tt qtlua interpreter tool:
  
  @image doc/hello_ui.png

 @end section

 @section T{Example 2 : Console use}

  This example shows how the @tt qtlua interactive mode can be used to create widgets,
  set properties and play with Qt objects.

  The first screenshot partially shows the list of available fields in a newly created @ref QSpinBox widget:

  @image doc/qtlua_console_1.png

  The second screenshot shows how to update the spinbox buttons style property using the right Qt enumeration value:

  @image doc/qtlua_console_2.png

 @end section

@end section

@c @insert all_modules_sections

@section TPH {API documentation}
 @section {Modules list}
  @insert modules_table
 @end section
 @section {Classes list}
  @insert {bymodules} classes_table
 @end section
 @insert {TP} all_classes_sections
 @insert {TP} all_namespaces_sections
@end section

@section TP {GNU Free Documentation License}
 @include fdl-1.3.mkdoc
@end section

